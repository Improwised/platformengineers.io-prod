__NUXT_JSONP__("/blog/multi-stage-build-for-ci-cd-pipeline-using-dockerfile", (function(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q){return {data:[{blog:{id:b,status:"published",sort:19,date_created:"2024-06-10T10:35:32.094Z",date_updated:"2024-06-13T11:16:53.550Z",slug:"multi-stage-build-for-ci-cd-pipeline-using-dockerfile",title:g,description:"\u003Cp\u003E\u003Cstrong id=\"docs-internal-guid-78da0e51-7fff-f7e6-b4ae-e7a38613e20f\"\u003EDockerfile builds create monolithic images containing the entire application environment &ndash; application code, build tools, and runtime dependencies.\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E",seo_title:g,seo_description:"Dockerfile builds create monolithic images containing the entire application environment – application code, build tools, and runtime dependencies.",content:"\u003Cp dir=\"ltr\"\u003EDockerfile builds create monolithic images containing the entire application environment – application code, build tools, and runtime dependencies. While simple to understand, this approach leads to bulky images with a significant drawback: inefficiency within CI\u002FCD pipelines.\u003C\u002Fp\u003E\n\u003Cp dir=\"ltr\"\u003EMulti-stage builds are necessary for Continuous Integration and Continuous Deployment (CI\u002FCD) pipelines because they allow for more efficient and secure deployment processes. By breaking down the build process into stages, each stage can perform specific tasks, such as building the application, running tests, and creating a production-ready image. This approach reduces the risk of errors and vulnerabilities in the final image, as each stage can be tested and validated before moving on to the next stage. Multi-stage builds can reduce the size of the final image by removing unnecessary files and dependencies, improving the overall performance and security of the application.\u003C\u002Fp\u003E\n\u003Ch3 dir=\"ltr\"\u003ECore Concepts:\u003C\u002Fh3\u003E\n\u003Cp dir=\"ltr\"\u003E\u003Cstrong\u003ESeparation of Concerns: Build vs. Runtime Stages\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cp dir=\"ltr\"\u003EMulti-stage builds establish a clear distinction between the build environment and the runtime environment:\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli dir=\"ltr\" aria-level=\"1\"\u003E\n\u003Cp dir=\"ltr\" role=\"presentation\"\u003EBuild Stage: Focuses on building the application. It typically utilizes a base image containing the necessary build tools (compilers, linkers) and libraries for the specific programming language (e.g., golang:1.19-alpine for Go). The application code is copied into this stage, and build commands are executed to compile, link, and generate application binaries or artifacts. These artifacts are then staged for inclusion in the final image.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli dir=\"ltr\" aria-level=\"1\"\u003E\n\u003Cp dir=\"ltr\" role=\"presentation\"\u003ERuntime Stage: Focuses on running the application. It utilizes a minimal base image, often a lightweight image like alpine:3.16. The required application artifacts are carefully selected and copied from the build stage into the runtime image. Any additional runtime dependencies (e.g., system libraries) are installed in this stage to ensure the application functions properly within the container. This final image serves as the basis for deploying your application.\u003Cstrong\u003E\u003Cbr\u003E\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Ch3 dir=\"ltr\"\u003EUse Multi-Stage Builds\u003C\u002Fh3\u003E\n\u003Cp dir=\"ltr\"\u003EMulti-stage builds involve employing multiple \u003Ccode\u003E`FROM`\u003C\u002Fcode\u003E statements in a Dockerfile, with each statement initiating a new stage of the build. These stages can utilize different bases, and artifacts can be selectively copied from one stage to another, excluding unwanted elements in the final image.\u003C\u002Fp\u003E\n\u003Cp dir=\"ltr\"\u003EHere's an example demonstrating the separation of build and runtime environments:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E# syntax=docker\u002Fdockerfile:1\nFROM golang:1.21 as build\nWORKDIR \u002Fsrc\nCOPY \u003C\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EIn this example, the first stage utilizes Golang to compile the source code, while the second stage employs the \u003Ccode\u003E`scratch`\u003C\u002Fcode\u003E image, which contains only the compiled binary. This approach ensures a small, secure production image without superfluous build tools.\u003C\u002Fp\u003E\n\u003Ch3\u003EName Your Build Stages\u003C\u002Fh3\u003E\n\u003Cp\u003EBy default, stages are referred to by their integer number, starting with zero for the initial \u003Ccode\u003E`FROM`\u003C\u002Fcode\u003E instruction. However, stages can be named explicitly using the \u003Ccode\u003E`AS`\u003C\u002Fcode\u003E keyword, improving readability and resilience against reordering of instructions:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E\n# syntax=docker\u002Fdockerfile:1\nFROM golang:1.21 as build\nWORKDIR \u002Fsrc\nCOPY \u003C\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003EStop at a Specific Build Stage\u003C\u002Fh3\u003E\n\u003Cp\u003EWhen constructing an image, it is possible to stop at a particular stage using the \u003Ccode\u003E`--target`\u003C\u002Fcode\u003E flag during the build process. This capability is helpful for various scenarios, such as debugging a specific stage or managing distinct development and production environments:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E$ docker build --target build -t hello .\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch3\u003EUse External Image as a Stage\u003C\u002Fh3\u003E\n\u003Cp\u003EStages in multi-stage builds are not confined to previous stages within the same Dockerfile; they can also reference external images. This feature allows for greater flexibility and modularity in the build process:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003ECOPY --from=nginx:latest \u002Fetc\u002Fnginx\u002Fnginx.conf \u002Fnginx.conf\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EIn multi-stage builds, you aren't limited to copying from stages created earlier in your Dockerfile. You can use the \u003Ccode\u003E`COPY --from`\u003C\u002Fcode\u003E instruction to copy from a separate image:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E# syntax=docker\u002Fdockerfile:1\n\n\nFROM alpine:latest AS builder\nRUN apk --no-cache add build-base\n\n\nFROM builder AS build1\nCOPY \u003C\n\nint main() {\n    std::cout \u003C\u003C \"Hello from source1!\" \u003C\u003C std::endl;\n    return 0;\n}\nEOF\nRUN g++ -o \u002Fbinary source1.cpp\n\n\nFROM builder AS build2\nCOPY \u003C\n\n\nint main() {\n    std::cout \u003C\u003C \"Hello from source2!\" \u003C\u003C std::endl;\n    return 0;\n}\nEOF\nRUN g++ -o \u002Fbinary source2.cpp\n\n\nFROM nginx:latest\nCOPY --from=build1 \u002Fbinary \u002Fusr\u002Fshare\u002Fnginx\u002Fhtml\u002Findex.html\nCOPY --from=build2 \u002Fbinary \u002Fusr\u002Fshare\u002Fnginx\u002Fhtml\u002Flogin.html\n\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Ch2\u003EAdvanced Multi-Stage Build Techniques\u003C\u002Fh2\u003E\n\u003Ch3\u003EBuilding Multiple Artifacts\u003C\u002Fh3\u003E\n\u003Cp\u003EMulti-stage builds can be used to build multiple artifacts in a single Dockerfile. This technique is particularly useful when dealing with microservices or applications composed of multiple components.\u003C\u002Fp\u003E\n\u003Cp\u003EConsider the following example, demonstrating a multi-stage build for two Golang applications:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E# syntax=docker\u002Fdockerfile:1\n\nFROM golang:1.21 AS build1\nWORKDIR \u002Fsrc1\nCOPY \u003C\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EHere, two separate stages are used to build two distinct Golang applications. The final stage copies both binaries from their respective build stages and executes them together.\u003C\u002Fp\u003E\n\u003Ch3 dir=\"ltr\"\u003EBuilding for Multiple Architectures\u003C\u002Fh3\u003E\n\u003Cp\u003EMulti-stage builds can also be used to build for multiple architectures. This technique is particularly useful when targeting different platforms or environments.\u003C\u002Fp\u003E\n\u003Cp\u003EConsider the following example, demonstrating a multi-stage build for two different architectures:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003E# syntax=docker\u002Fdockerfile:1\n\n\nFROM golang:1.21 AS build-amd64\nWORKDIR \u002Fsrc\nCOPY \u003C\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EHere, two separate stages are used to build the same application for two different architectures. The final stage copies both binaries from their respective build stages and executes them together.\u003C\u002Fp\u003E\n\u003Ch3 dir=\"ltr\"\u003EBuilding image using BuildKit\u003C\u002Fh3\u003E\n\u003Cp\u003ETo build the image using BuildKit, you would run the following command:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003EDOCKER_BUILDKIT=1 docker build -t hello\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EBy setting \u003Ccode\u003E`DOCKER_BUILDKIT=1`\u003C\u002Fcode\u003E, you instruct Docker to use BuildKit for the build process. Without BuildKit, the Docker engine would attempt to build all stages leading up to the specified target, potentially wasting resources.\u003C\u002Fp\u003E\n\u003Cp\u003EWith BuildKit, only the stages that the target stage depends on are processed. In this case, since the \u003Ccode\u003E`runtime`\u003C\u002Fcode\u003E stage depends on the `build` stage, only those stages will be built. This leads to faster build times and reduced resource usage.\u003C\u002Fp\u003E\n\u003Cp\u003EYou can specify a target build stage using the \u003Ccode\u003E`--target`\u003C\u002Fcode\u003E option:\u003C\u002Fp\u003E\n\u003Cpre\u003E\u003Ccode\u003EDOCKER_BUILDKIT=1 docker build --target build -t hello\u003C\u002Fcode\u003E\u003C\u002Fpre\u003E\n\u003Cp\u003EThis will stop at the \u003Ccode\u003E`build`\u003C\u002Fcode\u003E stage and skip the \u003Ccode\u003E`runtime`\u003C\u002Fcode\u003E stage, which may be useful for debugging purposes or when creating separate build and runtime images.\u003C\u002Fp\u003E\n\u003Ch3 dir=\"ltr\"\u003EOptimizing CI\u002FCD Workflows:\u003C\u002Fh3\u003E\n\u003Cp\u003EThe final image size is significantly smaller compared to a traditional single-stage build, as unnecessary build tools and libraries are excluded. This translates to faster image transfers between the build server and container registry during the deployment process. Caching of build stages combined with the smaller final image size contributes to faster overall build times within CI\u002FCD pipelines. Smaller images inherently reduce the attack surface, potentially minimizing security vulnerabilities within your containerized application. \u003Ca href=\"https:\u002F\u002Fplatformengineers.io\u002Fblog\u002Fbest-practices-for-writing-dockerfiles\u002F\" target=\"_blank\" rel=\"noopener\"\u003EExplore best practices for writing efficient and secure Dockerfiles.\u003C\u002Fa\u003E\u003C\u002Fp\u003E\n\u003Cp\u003E\u003Cstrong\u003EConsiderations:\u003C\u002Fstrong\u003E\u003C\u002Fp\u003E\n\u003Cul\u003E\n\u003Cli\u003E\n\u003Cp dir=\"ltr\" role=\"presentation\"\u003EMulti-stage builds introduce additional complexity compared to single-stage builds. Understanding the separation of concerns and managing dependencies across stages becomes crucial.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli\u003E\n\u003Cp dir=\"ltr\" role=\"presentation\"\u003EEnsure the runtime base image has the necessary tools to handle tasks like copying files or setting environment variables.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003Cli dir=\"ltr\" aria-level=\"1\"\u003E\n\u003Cp dir=\"ltr\" role=\"presentation\"\u003EUsing minimal base images in the runtime stage might require additional security hardening steps to mitigate potential risks.\u003C\u002Fp\u003E\n\u003C\u002Fli\u003E\n\u003C\u002Ful\u003E\n\u003Cp\u003E&nbsp;\u003C\u002Fp\u003E",tags:a,time_to_read:"5 mins",user_created:{id:c,first_name:d,last_name:e,email:h,password:i,location:a,title:j,description:a,tags:a,avatar:f,language:a,tfa_secret:a,status:k,role:l,token:a,last_access:m,last_page:n,provider:o,external_identifier:a,auth_data:a,email_notifications:p,appearance:a,theme_dark:a,theme_light:a,theme_light_overrides:a,theme_dark_overrides:a},user_updated:{id:c,first_name:d,last_name:e,email:h,password:i,location:a,title:j,description:a,tags:a,avatar:f,language:a,tfa_secret:a,status:k,role:l,token:a,last_access:m,last_page:n,provider:o,external_identifier:a,auth_data:a,email_notifications:p,appearance:a,theme_dark:a,theme_light:a,theme_light_overrides:a,theme_dark_overrides:a},image:{id:"84fa5dbb-6e76-4e31-8a69-127bd1d7fa58",storage:"AMZ",filename_disk:"84fa5dbb-6e76-4e31-8a69-127bd1d7fa58.png",filename_download:"hand-drawn-flat-design-sql-illustration.png",title:"Hand Drawn Flat Design SQL Illustration",type:"image\u002Fpng",folder:"33b4de25-d0f2-4999-ba32-6883f9932c34",uploaded_by:c,uploaded_on:"2024-06-10T10:32:00.061Z",modified_by:a,modified_on:"2024-06-10T10:32:02.204Z",charset:a,filesize:"837133",width:q,height:q,duration:a,embed:a,description:a,location:a,tags:a,metadata:{},focal_point_x:a,focal_point_y:a},authors:[{id:26,pe_blog_id:b,directus_users_id:{first_name:"Satish",last_name:"Annavar ",avatar:"33d28adb-eb7a-47f1-adc1-2233c7f06711"}},{id:27,pe_blog_id:b,directus_users_id:{first_name:d,last_name:e,avatar:f}}]},_img:{"/_ipx/f_png/img/plateform-engineers.png":"\u002F_nuxt\u002Fimage\u002Fe7b705.png","/_ipx/f_png,s_68x55/img/plateform-engineers.png":"\u002F_nuxt\u002Fimage\u002F418082.png","/_ipx/f_png,s_32x40/https://data.improwised.com/assets/33d28adb-eb7a-47f1-adc1-2233c7f06711":"\u002F_nuxt\u002Fimage\u002F32d461.png","/_ipx/f_png,s_32x40/https://data.improwised.com/assets/20d037d1-41ee-4efd-b034-1350a3ce336d":"\u002F_nuxt\u002Fimage\u002Fa07868.png","/_ipx/h_400,f_png/https://data.improwised.com/assets/84fa5dbb-6e76-4e31-8a69-127bd1d7fa58":"\u002F_nuxt\u002Fimage\u002F3f2685.png","/_ipx/f_png,h_400/https://data.improwised.com/assets/84fa5dbb-6e76-4e31-8a69-127bd1d7fa58":"\u002F_nuxt\u002Fimage\u002F170e5c.png"}}],fetch:{},mutations:[]}}(null,21,"f6ae4b64-c3c4-4f35-8b41-9f48088de4b1","Angita","Shah","20d037d1-41ee-4efd-b034-1350a3ce336d","Multi-Stage Build for CI\u002FCD Pipeline using Dockerfile","angita.shah@improwised.com","**********","SEO Specialist","active","5ef170ac-f2e9-4b93-a9ea-5c54fcf0fa40","2024-08-13T09:12:37.282Z","\u002Fcontent\u002Fpe_industry","default",true,2000)));